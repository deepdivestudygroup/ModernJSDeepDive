https://velog.io/@blueorangeade/3%EC%A3%BC%EC%B0%A8

15장~21장

### 15장 let, const 키워드와 블록 레벨 스코프
var 
변수 중복선언 허용, 함수 레벨 스코프, 
변수호이스팅되어서 undefined로 초기화 되기때문에 선언문 이전에 참조가 가능
let
변수 중복선언 X, 블록레벨스코프, 변수가 호이스팅 되지만 
선언단계화 초기화 단계 사이에 tdz에 놓이게 되어 선언문 이전에 참조하면 에러를 발생시켜서 호이스팅 되지 않는것 처럼 동작한다.
const
변수 중복선언 X, 블록레벨스코프, 재할당 금지,
선언과 초기화가 반드시 동시에 되어야 함


### 16장 프로퍼티 어트리뷰트

**내부슬롯과, 내부메서드** --> 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 
ECMAScript 사양에서 사용하는 pseudo property와 pseudo method다.
[[]]이중슬롯으로 감싸져있다. 
내부슬롯과 내부메서드는 자바스크립트 엔진의 내부로직이므로 원칙적으로 내부슬롯과 내부메서드에 직접적으로 접근하거나 호출할 수 있는 방법X 
단, 일부 내부 슬롯과 내부 메서드만 접근가능
ex) 모든 객체는 [[prototype]] 이라는 내부슬롯을 갖는다
프로토타입은 JavaScript 엔진 내부에서 관리되는 구조이지만, 개발자가 필요할 때 프로토타입의 정보에 접근하고 확인할 수 있도록 _ _ proto _ _를 통해 간접적으로 접근 가능 

**프로퍼티 어트리뷰트**
자바스크립트 엔진이 관리하는 내부 상태 값인 내부슬롯이다.
object.getOwnPropertyDescriptor(s)메서드로 간접적으로 확인할 수 있고 디스크립터 객체를 반환한다. 

-데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티, 
데이터 프로퍼티 어트리뷰트: [[Value]],[[Writable]],[[Enumerable]],[[Configurable]]
-접근자 프로퍼티: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(getter/setter함수)로 구성된 프로퍼티
접근자 프로퍼티의 어트리뷰트: [[Get]],[[Set]],[[Enumerable]],[[Configurable]]

**프로퍼티정의**
object.defineProperty메서드로 
프로퍼티의 어트리뷰트를 정의할 수 있다.
```
const person = {};

//데이터 프로퍼티 정의
object.defineProperty(person, 'firstName',{
	value: 'Ungmo',
	writable: ture,
	enumerable: ture,
	configurable: true});

//접근자 프로퍼티 정의
object.defineProperty(person, 'fullName',{
//getter함수
get(){
	return `${this.firstName}${this.lastName}`
},
//setter함수
set(){
	[this.firstName, this.lastName] = name.split(' ');
},
enumerable: ture,
configurable: true
})
```

**객체 변경 방지**

| 구분   | 메서드               | 프로퍼티 추가 | 삭제 | 값 읽기 | 값 갱신 | 어트리뷰트 재정의 |
|--------|----------------------|---------------|------|---------|---------|------------------|
| 객체 확장 금지 | `Object.preventExtensions(obj)` | X             | O    | O       | O       | O                |
| 객체 밀봉   | `Object.seal(obj)`    | X             | X    | O       | O       | X                |
| 객체 동결   | `Object.freeze(obj)`  | X             | X    | O       | X       | X                |

--> 얕은 변경방지
--> Object.freeze를 모든프로퍼티에 재귀적으로 적용하면 중첩객체까지 동결가능

### 17장 생성자 함수에 의한 객체생성
```
const person = new Object();
```
new연산자와 함께 object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
생성자 함수에 의해 생성된 객체를 **인스턴스**라한다.

객체리터럴에 의한 객체 생성방식은 직관적이고 간편하지만 동일한 프로퍼티를 갖는 객체를 생성해야 하는 경우 생성자 함수를 통해 객체를 생성하는게 더 효율적

함수는 객체이기 때문에 일반객체가 가지고 있는 내부슬롯과 내부메서드를 가지고 있다. 
함수만 가지고 있는
내부슬롯: [[Envionment]],[[Formal Parameters]]
내부 메서드: [[call]],[[construct]]

함수가 일반함수로서 호출되면 함수객체의 내부메서드 [[call]]이 호출되고,
new연산자와 함께 생성자 함수로서 호출되면 내부 메서드[[construct]]가 호출된다.

모든 함수객체는 내부메서드 [[call]]을 갖고 있어서 callable이지만
[[construct]]일수도 있고 아닐수도 있다.(옵션)

함수정의에 따라 construct와 non-construct를 구분하고
**함수선언문과 표현식으로 정의된 함수만이 constructor다**

### 18장 함수와 일급 객체

함수는 일급객체이므로 함수와 객체를 동일하게 사용할 수 있다.
객체는 값이므로 함수는 값과 동일하게 취급할 수 있다.
**일급객체**
1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다
2. 변수나 자료구조(객체, 배열 등)에 저장할 . 수있다.
3. 함수의 매개변수에 전달할 수 있다
4. 함수의 반환값으로 사용할 수 있다.

함수 객체의 프로퍼티
1. arguments
: 인수들의 정보를 담고 있는 순회가능한 유사배열객체, 함수내부에서 지역변수처럼사용
2. caller
: ECMAScript의 비표준 프로퍼티로 함수자신을 호출한 함수를 가르킴
3. length
: 매개변수(parameter)의 개수를 가리킨다.
4. name
: 함수의 이름을 나타냄
5.  _ proto _ 접근자 프로퍼티
: 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다.
6. prototype 프로퍼티
: constructor만이 소유하는 프로퍼티로 
생성자함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로포타입 객체를 가리킨다. 


### 19장 프로토타입

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.
프로토타입은 어떤 객체의 상위객체의 역할을 하는 객체로서 다른객체에 공유 프로퍼티(메서드 포함)를 제공한다. 
모든 객체는 [[prototype]]이라는 내부슬롯을 가지며, 내부슬롯의 값은 프로토타입의 참조다. [[prototype]]에 저장되는 프로토타입은 객체 생성방식에 의해결정된다. 객체 리터럴에 의해 생성된 객체의 프로토타입은 object.prototype이고 생성자함수에 의해 생성된 객체의 프로토타입은 생성자함수의 prototype프로퍼티에 바인딩되어있는 객체다. 

모든 객체는 _ _ proto _ _ 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있다. 

| 구분 | 소유 | 값 | 사용주체 | 사용목적 |
|-------|-------|-------|-------|-------|
| _ _ proto _ _  접근자 프로퍼티| 모든객체 | 프로토타입의 참조 | 모든객체 | 객체가 자신의 프로토타입에 접근 또는 교체하기위해 사용 |
| prototype 프로퍼티 | constructor | 프로토타입의 참조 | 생성자함수 |  함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |
프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘
Object.prototype을 프로토타입 체인의 종점(end of prototype chain)이라하고, Object.prototype의 프로토타입, 즉 [[prototype]]의 내부슬롯의 값은 null이다. 

프로퍼티 존재확인 
-in 연산자  (모든 프로토타입의 프로퍼티를 확인하므로 주의 )
-Object.prototype.hasOwnProperty메서드: 인수로 전달받은 키가 객체고유의 프로퍼티인 경우에만 true 반환 

프로퍼티 열거
for...in
--> 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다. 객체 자신의 프로퍼티만 열거하려면 Object.prototype.hasOwnProperty메서드를 사용해야한다. 


### 20장 strict mode

ES5부터 추가되었고, 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수있는 코드에 대해 명시적인 에러를 발생시킨다. 
ESLint 같은 린트 도구를 사용해 strict mode와 유사한 효과를 얻을 수 있다. 암묵적 전역, 변수,함수, 매개변수의 삭제나, 매개변수 이름의 중복, with문의 사용시 에러를 일으킨다. 


### 21장 빌트인 객체

자바스크립트 객체의 분류
-> 표준 빌트인 객체: 실행환경과 관련없이 언제나 사용, 전역객체로 언제나 참조가능
-> 호스트 객체: 실행환경에서 추가로 제공하는 객체
-> 사용자 정의 객체: 사용자가 직접 정의한 객체 

표준 빌트인 객체
Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 

원시값과 래퍼객체
문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시객체를 래퍼객체라 한다. 래퍼객체의 처리가 종료되면 래퍼객체의 내부슬롯에 할당된 원시값으로 원래의 상태로 되돌리고 래퍼객체는 가비지컬렉션의 대상이 된다. 

전역객체
코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체
표준빌트인객체, 호스트객체, 그리고 var키워드로 선언한 전역변수와 전역함수를 프로퍼티로 갖는다. 개발자가 의도적으로 생성할 수 없고, 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다. 






**퀴즈**
호이스팅이란?
프로퍼티란?
프로토타입이란?
const 키워드로 선언된 변수에 객체를 할당한 경우, 객체의 값은 변경가능한가요?
인스턴스란?
함수와 일반객체의 큰 차이점은?
컨스트럭터가 아닌 함수는 프로포타입 프로퍼티가 있나요?

